{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///(webpack)/buildin/global.js","webpack:///./src/about-state.js","webpack:///./src/asset-load-state.js","webpack:///./src/entry-state.js","webpack:///./src/font-load-state.js","webpack:///./src/game-over-state.js","webpack:///./src/index.js","webpack:///./src/instructions-state.js","webpack:///./src/play-state.js","webpack:///./src/prisoners-instructions-state.js","webpack:///./src/torch-handler.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;AClFA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;;;;;;;ACnBA;;AAEA;;AAEA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;;AAEA,2CAA2C;AAC3C;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;;;;;;;;;;;;;;;AChCA;;AAEA;AACA,oDAAoD,KAAK;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B;AACA;;AAEA,gDAAgD,KAAK;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA,gE;AACA;;AAEA;AACA;AACA;;AAEA,YAAY;;AAEZ,C;;;;;;;;;;;;;;;ACnDA;;AAEA;AACA;AACA;;AAEA,SAAS;;AAET;AACA,SAAS;;AAET;;AAEA,8BAA8B;AAC9B;AACA;;AAEA,+BAA+B;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA;;;;;;;;;;;;;;;AC7CA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;AC7BA;;AAEA;AACA,0BAA0B;AAC1B;AACA;;AAEA,2BAA2B;AAC3B;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA,YAAY;AACZ,C;;;;;;;;;;;;;;;;;;;;;ACjBA;AACA;AACqC;AACrC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClBA;;AAEA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B;;AAEA,gCAAgC;AAChC;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA,YAAY;AACZ,C;;;;;;;;;;;;;;;ACjCA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D,sDAAsD;AACtD;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B,wBAAwB;AACxB;AACA;AACA;AACA;AACA,mBAAmB;AACnB,gBAAgB;AAChB,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;;AAE1B;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA,sBAAsB,WAAW;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB,oBAAoB;AAC7C;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,4CAA4C;AAC5C,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB;AACvB;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,yBAAyB;AAChD;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA,uCAAuC,eAAe;AACtD,4CAA4C,oBAAoB;AAChE,oCAAoC,cAAc;AAClD;AACA,iBAAiB;AACjB,mCAAmC,eAAe,KAAK,6BAA6B;AACpF;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,YAAY;AACZ;;;;;;;;;;;;;;;AC5zBA;;AAEA,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,+BAA+B;AAC/B;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA,YAAY;AACZ,C;;;;;;;;;;;;;;AC9CA;;AAEA;AACA;;AAEA;AACA;AACA,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import entryState from './entry-state';\n\nexport default function aboutState(game) {\n\n    let textCrawlStyle = { font: '10pt Press Start 2P', fill: 'white', align: 'left', wordWrap: true, wordWrapWidth: game.width-60};\n    let textCrawl = 'Premise\\n\\n'\n                    + 'The Kingdom of Fecea is asphyxiating from the nauseating fumes of crime, bankruptcy, and moral degeneracy.\\n'\n                    + 'Brigands, highway robbers, and non-humans frustrate the attempts of the Kingdom\\'s law enforcement to maintain order.\\n\\n'\n                    + 'In the bowels of the Kingdom\\'s most infamous gaol, you are Thelonious, the lone executioner. The prison is running out of space!';\n\n    return {\n        create: function() {\n            let buttonStyle = { font: '10pt Press Start 2P', fill: '#FFFFFF', align: 'left'};\n            let backButton = game.add.text(60, 30, '< Back', buttonStyle);\n\n            let instructionsButtonStyle = { font: '10pt Press Start 2P', fill: '#FFFFFF', align: 'right'};\n            let instructionsButton = game.add.text(game.world.width - 240, 30, 'Instructions >', instructionsButtonStyle);\n\n            backButton.inputEnabled = true;\n            backButton.events.onInputUp.add(function () {\n                game.state.start('Entry');\n            });\n\n            instructionsButton.inputEnabled = true;\n            instructionsButton.events.onInputUp.add(() => {\n                game.state.start('Instructions');\n            });\n\n            let aboutText = game.add.text(60, 90, textCrawl, textCrawlStyle);\n        }\n    };\n\n};\n","export default function assetLoadState(game) {\n\n    function preload() {\n        const sound = (name) => `src/assets/sound/${name}.mp3`;\n        game.load.audio('theme', sound('theme'));\n        game.load.audio('gateopensound', sound('gateopensound'));\n        game.load.audio('grindsound', sound('grindsound'));\n        game.load.audio('screamsound', sound('screamsound'));\n        game.load.audio('swingsound', sound('swingsound'));\n        game.load.audio('escapesound', sound('escapesound'));\n        game.load.audio('escapesound2', sound('escapesound2'));\n        game.load.audio('prisonmurdersound', sound('prisonmurdersound'));\n\n        let titleStyle = { font: '50pt Press Start 2P', fill: '#FFFFFF', align: 'center'};\n        let text = game.add.text(game.world.centerX, game.world.centerY, ' Loading...', titleStyle);\n        text.anchor.set(0.5);\n\n        const img = (name) => `src/assets/img/${name}.png`;\n        game.load.spritesheet('ogre', img('ogre'), 96/2, 72);\n        game.load.spritesheet('player', img('player'), 64/2, 64);\n        game.load.image('bg', img('bgfull'));\n        game.load.spritesheet('elf', img('elf'), 64/2, 64);\n        game.load.spritesheet('hobbit', img('hobbit'), 64/2, 32);\n        game.load.spritesheet('usurper', img('usurper'), 64/2, 64);\n        game.load.spritesheet('rebel', img('rebel'), 64/2, 64);\n        game.load.spritesheet('goblin', img('goblin'), 64/2, 32);\n        game.load.image('ladder', img('ladderglow'));\n        game.load.image('capturebox', img('capturebox'));\n        game.load.spritesheet('torch', img('torch'), 8, 16);\n        game.load.image('pointer', img('pointer'));\n        game.load.image('choppingblock', img('choppingblock'));\n        game.load.spritesheet('bars', img('bars'), 426/3, 100);\n        game.load.spritesheet('glowbars', img('glowbars'), 426/3, 100);\n        game.load.image('glow', img('glow'));\n        game.load.image('axe', img('axe'));\n        game.load.image('heart', img('heart'));\n        game.load.image('choppingblockglow', img('choppingblockglow'));\n        game.load.spritesheet('axegrind', img('axegrind'), 112/2, 48);\n        game.load.spritesheet('axeloading', img('axeloading'), 72, 25);\n\n        \n           \n        window.theme = new Phaser.Sound(game, 'theme', 2, true); \n    }\n\n    function create() {\n        game.state.start('Entry');\n    }\n\n    return {preload, create};\n\n}","import playState from './play-state';\n\nexport default function entryState(game) {\n    return {\n        preload: function() {\n            \n        },\n\n        init: function() {\n        },\n \n        create: function() {\n            \n            let titleStyle = { font: '50pt Press Start 2P', fill: '#FFFFFF', align: 'center'};\n            let text = game.add.text(game.world.centerX, 100, 'Due Process', titleStyle);\n            text.anchor.set(0.5);\n\n            var optionStyle = { font: '30pt Press Start 2P', fill: 'white', align: 'left' };\n            var startOption = game.add.text(30, 280, 'Start', optionStyle);\n            var aboutOption = game.add.text(30, 380, 'About', optionStyle);\n\n            startOption.inputEnabled = true;\n            startOption.events.onInputUp.add(function () {\n                game.state.add('Play', playState(game));\n                game.state.start('Play');\n            });\n\n            aboutOption.inputEnabled = true;\n            aboutOption.events.onInputUp.add(function() {\n                game.state.start('About');\n            });\n            if(!window.theme.isPlaying) {\n                window.theme.play();\n            }\n\n            // RESTART this state because FOR SOME REASON\n            // the THEMESONG only plays the second time the state is entered\n            // *enraged screaming ensues*\n            game.state.start('Entry');\n        },\n\n        update: function() {\n            \n        }\n    }\n};\n","export default function fontLoadState(game) {\n\n    window.fontsLoaded = function() {\n        game.state.start('AssetLoad');\n    }\n\n    return {\n        preload: function() {\n            //  The Google WebFont Loader will look for this object, so create it before loading the script.\n            global.WebFontConfig = {\n\n                //  'active' means all requested fonts have finished loading\n                //  We set a 1 second delay before calling 'createText'.\n                //  For some reason if we don't the browser cannot render the text the first time it's created.\n                active: function() {\n                    game.time.events.add(Phaser.Timer.SECOND, fontsLoaded, this);\n                },\n\n                //  The Google Fonts we want to load (specify as many as you like in the array)\n                google: {\n                    families: ['Press Start 2P']\n                }\n            };\n\n            //  Load the Google WebFont Loader script\n            game.load.script('webfont', '//ajax.googleapis.com/ajax/libs/webfont/1.4.7/webfont.js');\n        }\n    };\n\n}\n","export default function gameOverState(game) {\n\n    function create() {\n        let titleStyle = { font: '50pt Press Start 2P', fill: '#FFFFFF', align: 'center'};\n        let text = game.add.text(game.world.centerX, game.world.centerY, 'Game Over', titleStyle);\n        text.anchor.set(0.5);\n\n        let buttonStyle = { font: '10pt Press Start 2P', fill: '#FFFFFF', align: 'left'};\n        let backButton = game.add.text(60, 30, '< Back', buttonStyle);\n\n        backButton.inputEnabled = true;\n        backButton.events.onInputUp.add(function () {\n                game.state.start('Entry');\n        });\n    }\n    \n    return {create};\n}","import fontLoadState from './font-load-state';\nimport assetLoadState from './asset-load-state';\nimport playState from './play-state'; // initialize the play state in entry state to reset all the variables in play state\nimport entryState from './entry-state';\nimport aboutState from './about-state';\nimport gameOverState from './game-over-state';\n\nimport instructionsState from './instructions-state';\nimport prisonersInstructionsState from './prisoners-instructions-state';\n\nconst game = new Phaser.Game(960, 540, Phaser.AUTO, 'game', undefined, undefined, false);\ngame.state.add('FontLoad', fontLoadState(game));\ngame.state.add('AssetLoad', assetLoadState(game));\ngame.state.add('Entry', entryState(game));\ngame.state.add('About', aboutState(game));\ngame.state.add('GameOver', gameOverState(game));\ngame.state.add('Instructions', instructionsState(game));\ngame.state.add('Prisoners', prisonersInstructionsState(game));\ngame.state.start('FontLoad');\n","export default function instructionsState(game) {\n\n    let instructionsTextStyle = { font: '10pt Press Start 2P', fill: 'white', align: 'left', wordWrap: true, wordWrapWidth: game.width-60};\n    let instructionsText = 'Gain points for every prisoner who dies!!!\\n\\n'\n                         + '1. Move by right clicking.\\n\\n'\n                         + '2. Prisoners will queue up by the door. Click on them to attend to them.\\n\\n'\n                         + '3. While attending to a prisoner, you can excort them to a cell or to the chopping block.\\n\\n'\n                         + '4. Cells can hold two prisoners, and they interact with eachother. Some prisoners kill eachother (good),'\n                         + 'but if two prisoners of the same type share a cell for too long, they can escape!\\n\\n'\n                         + '5. Each prisoner who escapes takes one of your lives with them!\\n\\n'\n                         + '6. The chopping block requires the axe to be sharpened after each use (its availability can be seen at the top).';\n\n    function create() {\n        let backButtonStyle = { font: '10pt Press Start 2P', fill: '#FFFFFF', align: 'left'};\n        let backButton = game.add.text(60, 30, '< Back', backButtonStyle);\n\n        let racesButtonStyle = { font: '10pt Press Start 2P', fill: '#FFFFFF', align: 'left'};\n        let racesButton = game.add.text(game.world.width - 240, 30, 'Prisoners >', racesButtonStyle);\n\n        backButton.inputEnabled = true;\n        backButton.events.onInputUp.add(function () {\n            game.state.start('About');\n        });\n\n        racesButton.inputEnabled = true;\n        racesButton.events.onInputUp.add(() => {\n            game.state.start('Prisoners');\n        });\n\n        game.add.text(60, 90, instructionsText, instructionsTextStyle);\n    }\n\n    return {create};\n}","import torchHandler from './torch-handler'\n\nexport default function playState(game) {\n    const debugOn = false;\n\n\n    const prisonerSpawnX = 200;\n    const playerWalkSpeed = 250/60;\n    const playerClimbSpeed = 300/60;\n    const races = [ 'elf', 'hobbit', 'usurper', 'rebel', 'goblin', 'ogre' ];\n    const levelYs = [ 175, 330 ];\n    const cellWidth = 142;\n    const grindDuration = 360;\n\n    // 'race': [things it hates]\n    const raceRelationsMap = {\n        'goblin': 'elf', // goblins hate elves, a hatred as old as the two races\n        'elf': 'rebel', // elves are nobler than rebels, causing the rebels to instigate a fight they can't win\n        'rebel': 'usurper', // rebels hate bourgeois usurpers; class struggle is real\n        'usurper': 'ogre', // usurpers dominate ogres; their commanding presence whittles away at the ogre\n        'ogre': 'hobbit', // ogres eat hobbits, and they are hungry\n        'hobbit': 'goblin', // hobbits outsmart goblins\n    };\n\n    let player;\n    let playerState = \"stand\"; // stand, moveladder, climb, move, dead\n    let playerLevel = 0; // 0=top floor, 1=next floor down\n    let playerLevelTarget = 0;\n    let playerTargetX;\n    let ladderA, ladderB;\n    let spaceTop, spaceBottom, waitingRoomBox;\n    let gonnaClimb; // which ladder you're heading to climb\n    let amClimb; // currently climbing\n    let prisoners = []; // every prisoner, regardless of their `state`, lives here\n    let waitingPrisoners = [];\n    let activePrisoner;\n    let clickedPrisoner;\n    let choppingBlock;\n    let axeGrind;\n    let cells = [];\n    let clickedCell;\n    let cellContents = [[null, null],[null, null],[null, null],[null, null],[null, null],[null, null]];\n    let score = 0;\n    let scoreText;\n    let axe;\n    let axeMurderTimer = 0;\n    let lives = 8;\n    let choppingblockGlow, ladderGlow, cellGlow, prisonerGlow;\n    let heartSprites = [];\n    let axeLoader;\n    let grindProgress = grindDuration;\n    let grindingAxe;\n    let nextPrisonerDelay = 360; // frames till next prisoner\n    let timeSinceLastPrisoner = 120;\n\n    // sounds\n    let gateOpenSound;\n    let grindAxeSound;\n    let screamSound;\n    let swingSound;\n    let prisonMurderSound;\n\n    let escapeSounds = []; let currEscapeSound = 0;\n\n    function preload() {\n        \n    }\n\n    function create() {\n        game.physics.startSystem(Phaser.Physics.ARCADE);\n\n        game.add.tileSprite(0, 0, 960, 540, 'bg');\n\n        // click-to-move areas\n        spaceTop = game.add.sprite(325, 20, 'capturebox');\n        spaceTop.alpha = 0.0;\n        spaceTop.width = 810;\n        spaceTop.height = 170;\n        spaceTop.inputEnabled = true;\n        spaceBottom = game.add.sprite(145, 200, 'capturebox');\n        spaceBottom.alpha = 0.0;\n        spaceBottom.width = 810;\n        spaceBottom.height = 170;\n        spaceBottom.inputEnabled = true;\n\n        // waiting area\n        waitingRoomBox = game.add.sprite(145, 20, 'capturebox');\n        waitingRoomBox.alpha = 0.0;\n        waitingRoomBox.width = 180;\n        waitingRoomBox.height = 170;\n        waitingRoomBox.inputEnabled = true;\n\n        // ladders\n        ladderA = game.add.sprite(327, 135, 'ladder');\n        ladderA.alpha = 0.0; // invisible ladders\n        ladderA.inputEnabled = true;\n        ladderB = game.add.sprite(905, 135, 'ladder');\n        ladderB.inputEnabled = true;\n        ladderB.alpha = 0.0;\n\n        // cells\n        const newCell = (x, y) => {\n            let c = game.add.sprite(x, y, 'bars');\n            c.animations.add('open', [0, 1, 2, 0]);\n            return c;\n        }\n        cells.push(newCell(393, 63));\n        cells.push(newCell(562, 63));\n        cells.push(newCell(732, 63));\n        cells.push(newCell(393, 223));\n        cells.push(newCell(562, 223));\n        cells.push(newCell(732, 223));\n        gateOpenSound = game.add.audio('gateopensound');\n\n        // torches\n        torchHandler(game).placeTorches();\n\n        // axe grind\n        axeGrind = game.add.sprite(200, levelYs[1], 'axegrind');\n        axeGrind.anchor.setTo(0.5, 1);\n        axeGrind.scale.setTo(1.5, 1.5);\n        let grindAnimation = axeGrind.animations.add('grind');\n        grindAxeSound = game.add.audio('grindsound');\n\n        // axe grinding - the axe that he grings :)\n        grindingAxe = game.add.sprite(200, levelYs[1] - 48, 'axe');\n        grindingAxe.alpha = 0;\n        grindingAxe.angle = -35;\n        grindingAxe.scale.x *= -1;\n\n        // chopping block\n        choppingBlock = game.add.sprite(250, levelYs[1], 'choppingblock');\n        choppingBlock.anchor.setTo(0.5, 0.7);\n        choppingBlock.inputEnabled = true;\n        swingSound = game.add.audio('swingsound');\n\n        // glows\n        ladderGlow = game.add.sprite(0,0,'ladder');\n        ladderGlow.alpha = 0;\n        cellGlow = game.add.sprite(0,0,'glowbars');\n        cellGlow.alpha = 0;\n        prisonerGlow = game.add.sprite(0,0,'glow');\n        prisonerGlow.alpha = 0;\n        choppingblockGlow = game.add.sprite(0,0,'choppingblockglow');\n        choppingblockGlow.alpha = 0;\n        choppingblockGlow.anchor.setTo(0.5, 0.7);\n\n\n        // the player\n        player = game.add.sprite(0, 0, 'player');\n        player.animations.add('walk');\n        player.anchor.setTo(0.5, 1);\n        player.x = 400;\n        player.y = levelYs[0];\n\n        // prisoner sounds\n        screamSound = game.add.audio('screamsound');\n        let escapeSound = game.add.audio('escapesound', 0.25);\n        let escapeSound2 = game.add.audio('escapesound2', 0.25);\n        escapeSounds = [escapeSound, escapeSound2];\n        prisonMurderSound = game.add.audio('prisonmurdersound');\n\n        // score\n        let scoreStyle = { font: '15pt Press Start 2P', fill: 'white', align: 'left' };\n        scoreText = game.add.text(650, 15, 'Score: 000000', scoreStyle);\n\n        // health\n        let heartX = 256;\n        let heartY = 15;\n        for(var i = 0; i < lives; ++i) {\n            heartX += 30;\n            heartSprites.push(game.add.sprite(heartX, heartY, 'heart'));\n        }\n\n        // axe loading\n        let axeLoadingX = 180;\n        let axeLoadingY = 15;\n        let axeLoadingBackground = game.add.sprite(axeLoadingX, axeLoadingY, 'axe');\n        axeLoadingBackground.alpha = 0.5;\n        axeLoadingBackground.angle = 90;\n        axeLoadingBackground.anchor.setTo(0, 1);\n        axeLoadingBackground.y = axeLoadingBackground - 4;\n\n        axeLoader = game.add.sprite(axeLoadingX, axeLoadingY, 'axeloading', 3);\n        axeLoader.animations.add('load');\n\n        space = game.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR);\n        debug = game.input.keyboard.addKey(Phaser.Keyboard.D);\n    }\n\n    let debug;\n    let lastDebug = false;\n    let space;\n    let lastSpace = false;\n\n    function update() {\n        if (debug.isDown && !lastDebug) {\n            debugger;\n        }\n\n        grindProgress++;\n        if (grindProgress >= grindDuration) {\n            grindProgress = grindDuration;\n            axeGrind.animations.stop('grind', true);\n            grindingAxe.alpha = 0;\n        }\n\n        updateCells();\n        updatePlayer();\n        updatePrisoners();\n\n        lastDebug = debug.isDown;\n        lastSpace = space.isDown;\n\n        timeSinceLastPrisoner++;\n        if(timeSinceLastPrisoner >= nextPrisonerDelay) {\n            timeSinceLastPrisoner = 0;\n            newPrisonerArrival();\n        }\n    }\n\n    /***********************************************************************************************************\n     * object class updates\n     */\n    function updateCells() {\n        for (let idx = 0; idx < cells.length; idx++) {\n            let c = cells[idx];\n            c.inputEnabled = // to be clickable...\n                !!activePrisoner && // player must carry a prisoner\n                (Math.floor(idx/3) === playerLevel) && // and be on the same vertical level as the cell\n                playerState !== 'climb'; // and not be currently climbing away from that vertical level\n        }\n    }\n\n    function updatePlayer() {\n        const checkClickOnLadder = () => {\n            ([ladderA, ladderB]).forEach((lad) => {\n                // phaser doesn't support \"did we click it this frame?\"\n                // so instead of tracking that shit for every object\n                // we just make sure this click started no more than ~20ms ago\n                // which means this will only be true for one frame (1f @60FPS = 16ms)\n                if (lad.input.justPressed(0, 20)) {\n                    gonnaClimb = lad;\n                    playerState = \"moveladder\";\n                    spawnGlow(gonnaClimb.x, gonnaClimb.y, ladderGlow);\n                    maybeStartClimb(); // don't bother moving to a ladder if you're already there\n                }\n            });\n        };\n\n        const checkClickOnSpace = () => {\n            if ((playerLevel === 0 && spaceTop.input.justPressed(0, 20)) ||\n                (playerLevel === 1 && spaceBottom.input.justPressed(0, 20))) {\n                playerState = 'move';\n                playerTargetX = game.input.activePointer.x;\n                spawnPointer(playerTargetX, levelYs[playerLevel]);\n            }\n        };\n\n        const checkClickOnWaitingRoom = () => {\n            if(waitingRoomBox.input.justPressed(0,20) && playerLevel === 0) {\n                playerTargetX = 330;\n                playerState = 'moveWaitingRoom';\n            }\n            maybeAttendPrisoner();\n        };\n\n        const checkClickOnCell = () => {\n            for (let i = 0; i < cells.length; i++) {\n                const b = cells[i];\n                if (b.input && b.input.justPressed(0, 20)) {\n                    clickedCell = i;\n                    playerTargetX = b.x + cellWidth/2;\n                    playerState = \"moveToCell\";\n                    spawnGlow(b.x, b.y, cellGlow);\n                }\n            }\n        };\n\n        const checkClickOnChoppingBlock = () => {\n            if (grindProgress >= grindDuration && playerLevel === 1 && choppingBlock.input.justPressed(0, 20)) {\n                playerState = 'moveToBlock';\n                playerTargetX = choppingBlock.x;\n                spawnGlow(choppingBlock.x, choppingBlock.y, choppingblockGlow);\n            }\n        };\n\n        const maybeAttendPrisoner = () => {\n            if(playerState === 'moveWaitingRoom' && isIntersect(waitingRoomBox, player)\n                && !activePrisoner) {\n                if(waitingPrisoners.length > 0) {\n                    activePrisoner = waitingPrisoners.shift();\n                    activePrisoner.state = 'followingPlayer';\n                } else {\n                    playerState = 'stand';\n                }\n            }\n        };\n\n        const maybeExecutePrisoner = () => {\n            if (activePrisoner && isIntersect(player, choppingBlock)) {\n                activePrisoner.state = 'murder';\n                playerState = 'murder';\n            }\n        };\n\n        const checkClickOnPrisoner = () => {\n            cellContents.forEach((prisonerArray) => {\n                prisonerArray.forEach((prisoner) => {\n                    if (prisoner && prisoner.inputEnabled\n                        &&  isSameFloor(player, prisoner)\n                        && prisoner.input.justPressed(0, 20)) {\n                        if(!activePrisoner) {\n                            playerState = 'moveToPrisoner';\n                            clickedPrisoner = prisoner;\n                            spawnGlow(prisoner.x - 22, prisoner.y, prisonerGlow);\n                        }\n                    }\n                })\n            });\n        }\n\n        const maybeLockHimUp = () => {\n            if (Math.abs(player.x - playerTargetX) <= playerWalkSpeed * 2) {\n                // only 2 slots per cell.\n                let slot = cellContents[clickedCell].indexOf(null);\n                if (slot < 0) { return; }\n                let cellSprite = cells[clickedCell];\n                cellSprite.animations.play('open', 15, false);\n                gateOpenSound.play();\n\n                cellSprite.bringToTop();\n                player.bringToTop();\n\n                // 0 slot in this cell is the left, 1 slot is the right.\n                const moveOver = !!cellContents[clickedCell][0] ? 40 : 0;\n\n                activePrisoner.state = 'thrownIn';\n                cellContents[clickedCell][slot] = activePrisoner;\n                activePrisoner.x = cells[clickedCell].x + cellWidth / 2 + moveOver;\n                activePrisoner.y = levelYs[Math.floor(clickedCell / 3)] - 30;\n                activePrisoner.anger = 0;\n                activePrisoner.camaraderie = 0;\n                activePrisoner.cellIndex = clickedCell;\n                activePrisoner = null;\n                clickedCell = undefined;\n                playState = 'stand';\n            }\n        };\n\n        const maybeStartClimb = () => {\n            if (isIntersect(gonnaClimb, player)) {\n                playerLevelTarget = Math.abs(1 - playerLevel); // switch between 0 and 1\n                playerState = \"climb\";\n                amClimb = gonnaClimb;\n                gonnaClimb = null;\n            }\n        };\n\n        const moveToTargetLadder = () => {\n            const direction = Math.sign(gonnaClimb.x - player.x);\n            player.x += direction * playerWalkSpeed;\n            if(activePrisoner) {\n                activePrisoner.x = player.x + direction * 48 * -1;\n                activePrisoner.y = player.y;\n            }\n\n            maybeStartClimb();\n        };\n\n        const climb = () => {\n            const climbDir = Math.sign(playerLevelTarget - playerLevel);\n            player.y += climbDir * playerClimbSpeed;\n            player.x = amClimb.centerX;\n            if(activePrisoner) {\n                activePrisoner.x = player.x;\n                activePrisoner.y = player.y + climbDir * -72;\n            }\n\n            // check if we just passed the level's Y coord\n            const currY = player.y;\n            const targetY = levelYs[playerLevelTarget];\n\n            if (climbDir === 1 && currY >= targetY ||  // down\n                climbDir === -1 && currY <= targetY ||\n                climbDir === 0) { // up\n                player.y = targetY;\n                playerLevel = playerLevelTarget;\n                playerState = \"stand\";\n                amClimb = null;\n            }\n        };\n\n        const moveToTargetSpace = () => {\n            const direction = Math.sign(playerTargetX - player.x);\n            player.x += direction * playerWalkSpeed;\n            if(activePrisoner) {\n                activePrisoner.x = player.x + direction * 48 * -1;\n                activePrisoner.y = player.y;\n            }\n\n            if (Math.abs(player.x - playerTargetX) < playerWalkSpeed) {\n                playerState = \"stand\";\n                player.x = playerTargetX;\n                playerTargetX = undefined;\n            }\n        };\n\n        const turnOnAnimations = () => {\n            player.animations.play('walk', 8, true);\n            if(activePrisoner) {\n                activePrisoner.animations.play('walk', 8, true);\n            }\n        };\n\n        const turnOffAnimations = () => {\n            player.animations.stop('walk', true);\n            if(activePrisoner) {\n                activePrisoner.animations.stop('walk', true);\n            }\n        };\n\n        const moveToPrisoner = () => {\n            if(isIntersect(player, clickedPrisoner)) {\n                let cellSprite = cells[clickedPrisoner.cellIndex];\n                cellSprite.animations.play('open', 15, false);\n                gateOpenSound.play();\n                clickedPrisoner.inputEnabled = false;\n                clickedPrisoner.state = 'followingPlayer';\n                clickedPrisoner.y = player.y;\n                activePrisoner = clickedPrisoner;\n                playerState = 'stand';\n                let cell = cellContents[clickedPrisoner.cellIndex];\n                let prisonerIndex = cell.indexOf(clickedPrisoner);\n                cell[prisonerIndex] = null;\n                let otherPrisoner = cell[(prisonerIndex + 1) % 2];\n                clickedPrisoner.anger = 0;\n                clickedPrisoner.camaraderie = 0;\n                if (otherPrisoner) {\n                    otherPrisoner.anger = 0;\n                    otherPrisoner.camaraderie = 0;\n                }\n                clickedPrisoner.cellIndex = null;\n                clickedPrisoner = null;\n                activePrisoner.bringToTop();\n            } else {\n                playerTargetX = clickedPrisoner.x;\n                moveToTargetSpace();\n            }\n        };\n\n        const doExecution = () => {\n            axeMurderTimer++;\n            player.x = choppingBlock.x - 64;\n            activePrisoner.x = choppingBlock.x + activePrisoner.height / Math.sqrt(2);\n            activePrisoner.angle = -45;\n            if (!axe) {\n                axe = game.add.sprite(player.x + 15, player.y - 36, 'axe');\n                axe.scale.setTo(0, 0);\n                axe.anchor.setTo(0.6, 1);\n            }\n\n            if (axeMurderTimer >= 0 && axeMurderTimer < 30) {\n                const scale = lerp(0, 1, axeMurderTimer / 30);\n                axe.scale.setTo(scale, scale);\n                screamSound.play();\n            } else if (axeMurderTimer >= 30 && axeMurderTimer < 60) {\n                swingSound.play();\n                const ang = lerp(0, -45, (axeMurderTimer - 30) / 30);\n                axe.angle = ang;\n            } else if (axeMurderTimer >= 60 && axeMurderTimer < 80) {\n                const ang = lerp(-45, 120, (axeMurderTimer - 60) / 20);\n                axe.angle = ang;\n            } else {\n                axe.destroy();\n                axe = undefined;\n                activePrisoner.destroy();\n                prisoners.splice(prisoners.indexOf(activePrisoner), 1);\n                activePrisoner = undefined;\n                playerState = 'stand';\n                axeMurderTimer = 0;\n                score += 10;\n                updateScore();\n\n                grindProgress = 0;\n                animateAxeLoading();\n                axeGrind.animations.play('grind', 10, true);\n                grindAxeSound.play();\n                grindingAxe.alpha = 1;\n            }\n        };\n\n        const checkClicks = function() {\n            checkClickOnChoppingBlock();\n            checkClickOnLadder();\n            checkClickOnSpace();\n            checkClickOnWaitingRoom();\n            checkClickOnCell();\n            checkClickOnPrisoner();\n        };\n\n        ({\n            stand: () => {\n                clickedPrisoner = null;\n                turnOffAnimations();\n                checkClicks();\n            },\n            moveladder: () => {\n                clickedPrisoner = null;\n                turnOnAnimations();\n                moveToTargetLadder();\n                checkClicks();\n            },\n            moveToCell: () => {\n                clickedPrisoner = null;\n                maybeLockHimUp();\n                turnOnAnimations();\n                moveToTargetSpace();\n                checkClicks();\n            },\n            move: () => {\n                clickedPrisoner = null;\n                turnOnAnimations();\n                moveToTargetSpace();\n                checkClicks();\n            },\n            climb: () => {\n                clickedPrisoner = null;\n                turnOnAnimations();\n                climb();\n            },\n            moveWaitingRoom: () => {\n                clickedPrisoner = null;\n                maybeAttendPrisoner();\n                turnOnAnimations();\n                moveToTargetSpace();\n                checkClicks();\n            },\n            moveToPrisoner: () => {\n                turnOnAnimations();\n                moveToPrisoner();\n                checkClicks();\n            },\n            moveToBlock: () => {\n                clickedPrisoner = null;\n                maybeExecutePrisoner();\n                turnOnAnimations();\n                moveToTargetSpace();\n                checkClicks();\n            },\n            murder: () => {\n                clickedPrisoner = null;\n                turnOffAnimations();\n                doExecution();\n            }\n        })[playerState]();\n    }\n\n    function updatePrisoners() {\n        // if (Math.random() * 100 > 99) {\n        if (debugOn && space.isDown && !lastSpace) {\n            newPrisonerArrival();\n        }\n\n        const moveForwardInLine = (prisoners, prisoner) => {\n            const amIBumpingIntoTheNextGuyInLineAndIfSoWhoIsIt = intersectsAny(prisoners, prisoner, (them) => them.x > prisoner.x);\n            if (isIntersect(prisoner, ladderA) ||\n                amIBumpingIntoTheNextGuyInLineAndIfSoWhoIsIt) {\n                prisoner.state = 'waitingroom';\n            } else {\n                prisoner.state = 'entering';\n                prisoner.x += 200/60;\n            }\n        };\n\n        const bideTimeInCell = function(prisoner) {\n            prisoner.inputEnabled = !activePrisoner;\n            let cell = cellContents[prisoner.cellIndex];\n            let hatedThings = cell.filter((toCheck) => {\n                return toCheck && toCheck.race === raceRelationsMap[prisoner.race];\n            });\n            if(hatedThings.length > 0) {\n                prisoner.anger++;\n            }\n            let helpfulThings = cell.filter((toCheck) => {\n                return toCheck && toCheck !== prisoner&& toCheck.race === prisoner.race;\n            });\n            if(helpfulThings.length > 0) {\n                prisoner.camaraderie++;\n            }\n\n            if(prisoner.anger > 300) {\n                hatedThings.forEach((thing) => {\n                    prisonMurderSound.play();\n                    const killThisIdx = cell.indexOf(thing);\n                    cell[killThisIdx] = null;\n                    destroyPrisoner(thing);\n                    score += 10;\n                    updateScore();\n                });\n                prisoner.anger = 0;\n            }\n\n            if(prisoner.camaraderie > 480) {\n                prisoner.state = 'escape';\n                prisoner.camaraderie = 0;\n                currEscapeSound = (currEscapeSound + 1) % 2;\n                escapeSounds[currEscapeSound].play();\n                \n            }\n        };\n\n        const escape = function(prisoner) {\n            if (prisoner.y > 200 && isIntersect(prisoner, ladderA)) {\n                prisoner.x = ladderA.centerX;\n                prisoner.y -= playerClimbSpeed;\n            } else {\n                if(prisoner.y > 200) {\n                    prisoner.y = levelYs[1]; // prisoner needs to be on lower floor walkway\n                } else {\n                    prisoner.y = levelYs[0];\n                }\n                prisoner.x -= playerWalkSpeed;\n            }\n\n            if (prisoner.x <= 190) { // 190 is the right edge of the door\n                destroyPrisoner(prisoner);\n                console.log('prisoner escaped!1!!');\n                takeLife();\n            }\n        };\n\n        prisoners.forEach((prisoner, idx) => {\n            if (!prisoner.alive) {\n                console.warn(\"attempted to update dead prisoner\", prisoner);\n                return; // skip him, he's been deleted and did not disappear somehow\n            }\n\n            ({\n                entering: () => {\n                    moveForwardInLine(waitingPrisoners, prisoner);\n                },\n                waitingroom: () => {\n                    moveForwardInLine(waitingPrisoners, prisoner);\n                },\n                followingPlayer: () => {\n                    prisoner.inputEnabled = false;\n                },\n                thrownIn: () => {\n                    bideTimeInCell(prisoner);\n                },\n                murder: () => {\n                    // TODO\n                },\n                escape: () => {\n                    prisoner.inputEnabled = false;\n                    let cell = cellContents[prisoner.cellIndex];\n                    cell[cell.indexOf(prisoner)] = null;\n                    escape(prisoner);\n                }\n            })[prisoner.state]();\n        });\n    }\n\n    function updateScore() {\n        scoreText.text = 'Score: ' + score.toString().padStart(6, '0');\n        if(score % 50 === 0) {\n            nextPrisonerDelay = nextPrisonerDelay > 120 ? nextPrisonerDelay - 30 : 120;\n        }\n    }\n\n    function takeLife() {\n        let heartSprite = heartSprites.shift();\n        if(heartSprite) {\n            heartSprite.destroy();\n            if(heartSprites.length < 1) {\n                game.state.start('GameOver');\n            }\n        }\n    }\n\n    function animateAxeLoading() {\n        const sections = 4;\n        const fps = 60;\n        const animationFps = fps / (grindDuration / (sections - 1));\n        axeLoader.animations.play('load', animationFps, false);\n    }\n\n    function isSameFloor(object1, object2) {\n        return object1.y && object2.y && (200 - object1.y) * (200 - object2.y) > 0;\n    }\n\n    /***********************************************************************************************************\n     * update helpers\n     */\n    function newPrisonerArrival() {\n        // lose a life for every prisoner that cannot fit into the queue\n        let lastPrisoner = waitingPrisoners[waitingPrisoners.length - 1];\n        if(lastPrisoner &&  lastPrisoner.x - prisonerSpawnX <= 16) {\n            takeLife();\n            return;\n        }\n        // pick random race\n        const race = races[Math.floor(Math.random() * races.length)];\n        let prisoner = game.add.sprite(prisonerSpawnX, levelYs[0], race);\n        prisoner.animations.add('walk');\n        prisoners.push(prisoner);\n        waitingPrisoners.push(prisoner);\n        prisoner.race = race;\n        prisoner.state = 'entering'; // entering, waitingroom\n        prisoner.anchor.setTo(0.5, 1);\n    }\n\n    function destroyPrisoner(prisoner) {\n        const idx = prisoners.indexOf(prisoner);\n        if (idx === -1) {\n            console.warn(\"Tried to destroy a prisoner but couldn't find him.\");\n        }\n        const vacateThis = findCellAndSlot(prisoner);\n        if (vacateThis) {\n            cellContents[vacateThis[0]][vacateThis[1]];\n        }\n\n        prisoners.splice(idx, 1);\n        prisoner.destroy();\n    }\n\n    function findCellAndSlot(prisoner) {\n        for (let c = 0; c < cellContents.length; c++) {\n            const cell = cellContents[c];\n            for (let s = 0; s < cell.length; s++) {\n                const pris = cell[c];\n                if (prisoner === pris)\n                    return [c, s];\n            }\n        }\n        return null;\n    }\n\n    function isIntersect(a, b) {\n        return Phaser.Rectangle.intersects(a.getBounds(), b.getBounds());\n    }\n\n    function intersectsAny(arrayOfThings, you, alsoSatisfy) {\n        /** if `you` intersects with anything in the array,\n        * return the first thing in the `arrayOfThings` that is intersecting.\n        * else null.\n        */\n       if (!alsoSatisfy) {\n           alsoSatisfy = (thing) => true;\n        }\n        for (let thing of arrayOfThings) {\n            if (thing === you) {\n                // can't collide with yourself\n                continue;\n            }\n            if (isIntersect(thing, you)) {\n                if (alsoSatisfy(thing)) {\n                    return thing;\n                }\n            }\n        }\n        return null;\n    };\n\n    function spawnPointer(x, y) {\n        let pointer = game.add.sprite(x, y, 'pointer');\n        pointer.anchor.setTo(0.5, 1);\n        const what = setInterval(() => {\n            pointer.alpha -= 0.05;\n            pointer.width += 0.5;\n            pointer.height += 0.5;\n            if (pointer.alpha <= 0) {\n                pointer.destroy();\n                clearInterval(what);\n            }\n        }, 16);\n    }\n\n    function spawnGlow(x, y, glow) {\n        // glow.anchor.setTo(0.5, 1);\n        // glow.x += glow.width/2;\n        // glow.y += glow.height;\n        // uncomment if you want to resize about the center\n        glow.alpha = 0;\n        glow.x = x;\n        glow.y = y;\n        glow.bringToTop();\n\n        let t = 0;\n        const id = setInterval(() => {\n            t += Math.PI / 30;\n            glow.alpha = Math.sin(t);\n            if (t >= Math.PI) {\n                glow.alpha = 0;\n                clearInterval(id);\n            }\n        }, 16);\n    }\n\n    function lerp(from, to, amt) {\n        return (1 - amt) * from + amt * to;\n    }\n\n    function render() {\n        if(debugOn) {\n            for (let prisoner of prisoners) {\n                game.debug.text(prisoner.state, prisoner.x - 32, prisoner.y - 64, \"green\");\n            }\n            for (let i = 0; i < cellContents.length; i++) {\n                const theCell = cellContents[i];\n                const formattedResidents = theCell.map((res) => {\n                    if (res === null) { return 'null'; }\n                    if (res === undefined) { return 'undefined'; }\n                    if (!res.race) { return '???'; }\n                    return res.race;\n                });\n                game.debug.text(`${theCell.length}: [${formattedResidents.join(',')}]`, 0, i * 16 + 400);\n            }\n            game.debug.text('grind progress: ' + grindProgress, 0, 6*16 + 400);\n            game.debug.text('activePrisoner: ' + (activePrisoner ? activePrisoner.race : '___'), 0, 7*16 + 400);\n            game.debug.text('clickedPrisoner: ' + (clickedPrisoner ? clickedPrisoner.race : '___'), 0, 8*16 + 400);\n            game.debug.text(playerState, player.x - 32, player.y - 64, \"white\");\n        }\n        \n    }\n\n    return {preload, create, update, render};\n}\n","export default function prisonersInstructionsState(game) {\n\n    let instructionsTextStyle = { font: '10pt Press Start 2P', fill: 'white', align: 'left', wordWrap: true, wordWrapWidth: game.width-60};\n\n    const races = [ 'elf', 'hobbit', 'usurper', 'rebel', 'goblin', 'ogre' ];\n    const descriptions = [\n        'Their nobility provokes the rebel, causing him to start a fight he can\\'t win.',\n        'They can outsmart (and eliminate) goblins.',\n        'They can dominate simple-minded ogres.',\n        'Hates the bourgeois usurpers.',\n        'Hatred of elves runs deep in this species.',\n        'Eats little hobbitses.'\n    ];\n\n    function preload() {\n        \n    }\n\n    function create() {\n        let backButtonStyle = { font: '10pt Press Start 2P', fill: '#FFFFFF', align: 'left'};\n        let backButton = game.add.text(60, 30, '< Back', backButtonStyle);\n\n        backButton.inputEnabled = true;\n        backButton.events.onInputUp.add(function () {\n            game.state.start('About');\n        });\n\n        let startY = 90;\n        let spriteX = 60;\n        let nameX = 120;\n        let descriptionX = 256;\n        let currY = startY;\n\n        races.forEach((raceName, i) => {\n            let prisoner = game.add.sprite(spriteX, currY, raceName);\n            prisoner.animations.add('walk');\n            prisoner.animations.play('walk', 8, true);\n            prisoner.anchor.setTo(0, 0.5);\n\n            game.add.text(nameX, currY, raceName, instructionsTextStyle);\n            game.add.text(descriptionX, currY, descriptions[i], instructionsTextStyle);\n            currY += 80;\n        });\n    }\n\n    return {preload, create};\n}","export default function torchHandler(game) {\n\n    let torchX = [225, 548, 718, 548, 718];\n    let torchY = [111, 111, 111, 271, 271];\n\n    return {\n        placeTorches: function() {\n            for(var i = 0; i < torchX.length; ++i) {\n                let torch = game.add.sprite(torchX[i], torchY[i], 'torch');\n                let light = torch.animations.add('light');\n                torch.animations.play('light', 12, true);\n            }\n        }\n    };\n\n}\n"],"sourceRoot":""}